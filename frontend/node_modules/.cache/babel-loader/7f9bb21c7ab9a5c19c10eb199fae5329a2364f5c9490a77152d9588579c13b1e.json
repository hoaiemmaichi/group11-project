{"ast":null,"code":"import axios from 'axios';\nconst API = process.env.REACT_APP_API_URL || 'http://localhost:3000';\n\n// Attach interceptors to the default axios instance so existing imports benefit\nlet isRefreshing = false;\nlet refreshSubscribers = [];\nfunction subscribeTokenRefresh(cb) {\n  refreshSubscribers.push(cb);\n}\nfunction onRefreshed(token) {\n  refreshSubscribers.forEach(cb => cb(token));\n  refreshSubscribers = [];\n}\n\n// Request interceptor: add Authorization header from localStorage if missing\naxios.interceptors.request.use(config => {\n  try {\n    var _config$headers;\n    const token = localStorage.getItem('token');\n    if (token && !((_config$headers = config.headers) !== null && _config$headers !== void 0 && _config$headers.Authorization)) {\n      config.headers = config.headers || {};\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n  } catch (e) {}\n  return config;\n}, error => Promise.reject(error));\n\n// Response interceptor: on 401 try to refresh token\naxios.interceptors.response.use(response => response, async error => {\n  const originalRequest = error.config;\n  if (!originalRequest) return Promise.reject(error);\n  // avoid infinite loop\n  if (error.response && error.response.status === 401 && !originalRequest._retry) {\n    originalRequest._retry = true;\n    const refreshToken = localStorage.getItem('refreshToken');\n    if (!refreshToken) {\n      // no refresh token, clear auth and reject\n      try {\n        localStorage.removeItem('token');\n        localStorage.removeItem('currentUser');\n      } catch (_) {}\n      return Promise.reject(error);\n    }\n    if (isRefreshing) {\n      // queue and retry once refreshed\n      return new Promise((resolve, reject) => {\n        subscribeTokenRefresh(token => {\n          if (!token) return reject(error);\n          originalRequest.headers.Authorization = `Bearer ${token}`;\n          resolve(axios(originalRequest));\n        });\n      });\n    }\n    isRefreshing = true;\n    try {\n      // use plain axios to call refresh endpoint (same instance but it's ok because _retry prevents loop)\n      const resp = await axios.post(`${API}/auth/refresh`, {\n        refreshToken\n      });\n      const newToken = resp.data.token;\n      const newRefresh = resp.data.refreshToken;\n      if (newToken) {\n        try {\n          localStorage.setItem('token', newToken);\n        } catch (_) {}\n        if (newRefresh) {\n          try {\n            localStorage.setItem('refreshToken', newRefresh);\n          } catch (_) {}\n        }\n        axios.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;\n        onRefreshed(newToken);\n        return axios(originalRequest);\n      }\n    } catch (e) {\n      // refresh failed: clear storage\n      try {\n        localStorage.removeItem('token');\n        localStorage.removeItem('refreshToken');\n        localStorage.removeItem('currentUser');\n      } catch (_) {}\n      onRefreshed(null);\n      return Promise.reject(e);\n    } finally {\n      isRefreshing = false;\n    }\n  }\n  return Promise.reject(error);\n});\nexport default axios;","map":{"version":3,"names":["axios","API","process","env","REACT_APP_API_URL","isRefreshing","refreshSubscribers","subscribeTokenRefresh","cb","push","onRefreshed","token","forEach","interceptors","request","use","config","_config$headers","localStorage","getItem","headers","Authorization","e","error","Promise","reject","response","originalRequest","status","_retry","refreshToken","removeItem","_","resolve","resp","post","newToken","data","newRefresh","setItem","defaults","common"],"sources":["/Users/lebao/Documents/TH_MNM/group11-project-frontend/frontend/src/api.js"],"sourcesContent":["import axios from 'axios';\n\nconst API = process.env.REACT_APP_API_URL || 'http://localhost:3000';\n\n// Attach interceptors to the default axios instance so existing imports benefit\nlet isRefreshing = false;\nlet refreshSubscribers = [];\n\nfunction subscribeTokenRefresh(cb) {\n  refreshSubscribers.push(cb);\n}\n\nfunction onRefreshed(token) {\n  refreshSubscribers.forEach(cb => cb(token));\n  refreshSubscribers = [];\n}\n\n// Request interceptor: add Authorization header from localStorage if missing\naxios.interceptors.request.use((config) => {\n  try {\n    const token = localStorage.getItem('token');\n    if (token && !config.headers?.Authorization) {\n      config.headers = config.headers || {};\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n  } catch (e) {}\n  return config;\n}, (error) => Promise.reject(error));\n\n// Response interceptor: on 401 try to refresh token\naxios.interceptors.response.use(response => response, async (error) => {\n  const originalRequest = error.config;\n  if (!originalRequest) return Promise.reject(error);\n  // avoid infinite loop\n  if (error.response && error.response.status === 401 && !originalRequest._retry) {\n    originalRequest._retry = true;\n    const refreshToken = localStorage.getItem('refreshToken');\n    if (!refreshToken) {\n      // no refresh token, clear auth and reject\n      try { localStorage.removeItem('token'); localStorage.removeItem('currentUser'); } catch(_){}\n      return Promise.reject(error);\n    }\n\n    if (isRefreshing) {\n      // queue and retry once refreshed\n      return new Promise((resolve, reject) => {\n        subscribeTokenRefresh((token) => {\n          if (!token) return reject(error);\n          originalRequest.headers.Authorization = `Bearer ${token}`;\n          resolve(axios(originalRequest));\n        });\n      });\n    }\n\n    isRefreshing = true;\n    try {\n      // use plain axios to call refresh endpoint (same instance but it's ok because _retry prevents loop)\n      const resp = await axios.post(`${API}/auth/refresh`, { refreshToken });\n      const newToken = resp.data.token;\n      const newRefresh = resp.data.refreshToken;\n      if (newToken) {\n        try { localStorage.setItem('token', newToken); } catch(_){}\n        if (newRefresh) { try { localStorage.setItem('refreshToken', newRefresh); } catch(_){} }\n        axios.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;\n        onRefreshed(newToken);\n        return axios(originalRequest);\n      }\n    } catch (e) {\n      // refresh failed: clear storage\n      try { localStorage.removeItem('token'); localStorage.removeItem('refreshToken'); localStorage.removeItem('currentUser'); } catch(_){}\n      onRefreshed(null);\n      return Promise.reject(e);\n    } finally {\n      isRefreshing = false;\n    }\n  }\n  return Promise.reject(error);\n});\n\nexport default axios;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}