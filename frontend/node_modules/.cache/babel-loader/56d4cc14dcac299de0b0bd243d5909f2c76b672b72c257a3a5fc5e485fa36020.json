{"ast":null,"code":"import axios from 'axios';\nconst API = process.env.REACT_APP_API_URL || 'http://localhost:3000';\n\n// Theo dõi trạng thái refresh token để tránh gọi nhiều lần\nlet isRefreshing = false;\nlet refreshSubscribers = [];\n\n// Thêm subscriber vào hàng đợi\nfunction subscribeTokenRefresh(callback) {\n  refreshSubscribers.push(callback);\n}\n\n// Thực thi tất cả callback trong hàng đợi với token mới\nfunction onRefreshed(token) {\n  refreshSubscribers.forEach(callback => callback(token));\n  refreshSubscribers = [];\n}\n\n// Hàm refresh token\nasync function refreshAuthToken() {\n  try {\n    const refreshToken = localStorage.getItem('refreshToken');\n    if (!refreshToken) {\n      throw new Error('No refresh token available');\n    }\n    const response = await axios.post(`${API}/auth/refresh`, {\n      refreshToken\n    });\n    const {\n      token: newAccessToken,\n      refreshToken: newRefreshToken\n    } = response.data;\n\n    // Lưu tokens mới\n    localStorage.setItem('token', newAccessToken);\n    if (newRefreshToken) {\n      localStorage.setItem('refreshToken', newRefreshToken);\n    }\n    return newAccessToken;\n  } catch (error) {\n    // Xóa hết tokens nếu refresh thất bại\n    localStorage.removeItem('token');\n    localStorage.removeItem('refreshToken');\n    localStorage.removeItem('currentUser');\n    throw error;\n  }\n}\n\n// Request interceptor: thêm Authorization header từ localStorage\naxios.interceptors.request.use(config => {\n  try {\n    var _config$headers;\n    const token = localStorage.getItem('token');\n    if (token && !((_config$headers = config.headers) !== null && _config$headers !== void 0 && _config$headers.Authorization)) {\n      config.headers = config.headers || {};\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n  } catch (e) {}\n  return config;\n}, error => Promise.reject(error));\n\n// Response interceptor: xử lý 401 và refresh token\naxios.interceptors.response.use(response => response, async error => {\n  const originalRequest = error.config;\n\n  // Nếu không phải lỗi 401 hoặc đã thử refresh rồi, reject luôn\n  if (!error.response || error.response.status !== 401 || originalRequest._retry) {\n    return Promise.reject(error);\n  }\n  originalRequest._retry = true;\n\n  // Nếu đang refresh token rồi thì đợi kết quả\n  if (isRefreshing) {\n    try {\n      const token = await new Promise((resolve, reject) => {\n        subscribeTokenRefresh(token => {\n          if (token) resolve(token);else reject(new Error('Failed to refresh token'));\n        });\n      });\n      originalRequest.headers['Authorization'] = `Bearer ${token}`;\n      return axios(originalRequest);\n    } catch (err) {\n      window.location.href = '/login';\n      return Promise.reject(err);\n    }\n  }\n\n  // Bắt đầu refresh token\n  isRefreshing = true;\n  try {\n    const newToken = await refreshAuthToken();\n    originalRequest.headers['Authorization'] = `Bearer ${newToken}`;\n    onRefreshed(newToken);\n    isRefreshing = false;\n    return axios(originalRequest);\n  } catch (refreshError) {\n    isRefreshing = false;\n    onRefreshed(null);\n    // Chuyển về trang login nếu refresh thất bại\n    window.location.href = '/login';\n    return Promise.reject(refreshError);\n  }\n});\nexport default axios;","map":{"version":3,"names":["axios","API","process","env","REACT_APP_API_URL","isRefreshing","refreshSubscribers","subscribeTokenRefresh","callback","push","onRefreshed","token","forEach","refreshAuthToken","refreshToken","localStorage","getItem","Error","response","post","newAccessToken","newRefreshToken","data","setItem","error","removeItem","interceptors","request","use","config","_config$headers","headers","Authorization","e","Promise","reject","originalRequest","status","_retry","resolve","err","window","location","href","newToken","refreshError"],"sources":["/Users/lebao/Documents/TH_MNM/group11-project-frontend/frontend/src/api.js"],"sourcesContent":["import axios from 'axios';\n\nconst API = process.env.REACT_APP_API_URL || 'http://localhost:3000';\n\n// Theo dõi trạng thái refresh token để tránh gọi nhiều lần\nlet isRefreshing = false;\nlet refreshSubscribers = [];\n\n// Thêm subscriber vào hàng đợi\nfunction subscribeTokenRefresh(callback) {\n  refreshSubscribers.push(callback);\n}\n\n// Thực thi tất cả callback trong hàng đợi với token mới\nfunction onRefreshed(token) {\n  refreshSubscribers.forEach(callback => callback(token));\n  refreshSubscribers = [];\n}\n\n// Hàm refresh token\nasync function refreshAuthToken() {\n  try {\n    const refreshToken = localStorage.getItem('refreshToken');\n    if (!refreshToken) {\n      throw new Error('No refresh token available');\n    }\n\n    const response = await axios.post(`${API}/auth/refresh`, { refreshToken });\n    const { token: newAccessToken, refreshToken: newRefreshToken } = response.data;\n\n    // Lưu tokens mới\n    localStorage.setItem('token', newAccessToken);\n    if (newRefreshToken) {\n      localStorage.setItem('refreshToken', newRefreshToken);\n    }\n\n    return newAccessToken;\n  } catch (error) {\n    // Xóa hết tokens nếu refresh thất bại\n    localStorage.removeItem('token');\n    localStorage.removeItem('refreshToken');\n    localStorage.removeItem('currentUser');\n    throw error;\n  }\n}\n\n// Request interceptor: thêm Authorization header từ localStorage\naxios.interceptors.request.use((config) => {\n  try {\n    const token = localStorage.getItem('token');\n    if (token && !config.headers?.Authorization) {\n      config.headers = config.headers || {};\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n  } catch (e) {}\n  return config;\n}, (error) => Promise.reject(error));\n\n// Response interceptor: xử lý 401 và refresh token\naxios.interceptors.response.use(\n  response => response,\n  async error => {\n    const originalRequest = error.config;\n    \n    // Nếu không phải lỗi 401 hoặc đã thử refresh rồi, reject luôn\n    if (!error.response || error.response.status !== 401 || originalRequest._retry) {\n      return Promise.reject(error);\n    }\n\n    originalRequest._retry = true;\n\n    // Nếu đang refresh token rồi thì đợi kết quả\n    if (isRefreshing) {\n      try {\n        const token = await new Promise((resolve, reject) => {\n          subscribeTokenRefresh(token => {\n            if (token) resolve(token);\n            else reject(new Error('Failed to refresh token'));\n          });\n        });\n        \n        originalRequest.headers['Authorization'] = `Bearer ${token}`;\n        return axios(originalRequest);\n      } catch (err) {\n        window.location.href = '/login';\n        return Promise.reject(err);\n      }\n    }\n\n    // Bắt đầu refresh token\n    isRefreshing = true;\n\n    try {\n      const newToken = await refreshAuthToken();\n      originalRequest.headers['Authorization'] = `Bearer ${newToken}`;\n      onRefreshed(newToken);\n      isRefreshing = false;\n      return axios(originalRequest);\n    } catch (refreshError) {\n      isRefreshing = false;\n      onRefreshed(null);\n      // Chuyển về trang login nếu refresh thất bại\n      window.location.href = '/login';\n      return Promise.reject(refreshError);\n    }\n  }\n);\n\nexport default axios;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}